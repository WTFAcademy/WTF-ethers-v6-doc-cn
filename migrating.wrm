_section: 从 v5 版本迁移 @<migrating> @priority<-10>

这份指南旨在捕捉 v5 和 v6 版本之间的一些高阶差异，帮助那些要迁移现有应用程序或已熟悉 v5 的人快速了解新版本。

v6 最大的不同之处在于使用现代 ES6 功能，因此很多变化在使用时是感受不到的。

- [BigNumbers](migrate-bigint)
- [Contracts](migrate-contracts)
- [Importing](migrate-importing)
- [其余变化](migrate-other)

_subsection: 大整数 Big Numbers  @<migrate-bigint>

v6最大的改变之一是 //BigNumber// 类已被现代 JavaScript 环境中内置的 ES2020 BigInt 取代。

有大量的[在线文档](link-js-bigint)可以帮助您开始学习JavaScript ES2020 BigInt。请记住，就像//BigNumber//一样，ES2020 BigInt 仅能够处理整数。

[[FixedNumber]]类仍然存在，用于进行定点数学运算。

_code: 创建大整数  @lang<script>

  // 在 v5 中使用 BigNumber 
  value = BigNumber.from("1000")

  // 在 v6 中使用 BigInt（使用文字表示法）。
  // 注意后缀 n
  value = 1000n

  // 对字符串使用 BigInt 函数
  value = BigInt("1000")

_code: 大整数运算  @lang<script>

  // 在 v5 中添加两个值
  sum = value1.add(value2)

  // 在 v6 中使用 BigInt；请记住，两个值
  // 都必须是 BigInt 
  sum = value1 + value2

_code: 大整数比较  @lang<script>

  // 在 v5 中检查是否相等
  isEqual = value1.eq(value2)

  // 在 v6 中使用 BigInt 
  isEqaul = (value1 == value2)



_subsection: 合约 Contracts @<migrate-contracts>

[[Contract]] 是一个 ES6 Proxy，这意味着它可以在运行时解析方法名称。

_heading: 有歧义的方法

在 v5 中，在有歧义的方法的情况下，有必要通过规范规范化签名查找方法。在 v6 中，不需要对签名进行规范化，Typed API 提供了一种更简洁的方式来访问所需的方法。

在 v5 中，重复定义还会将警告注入控制台，因为无法在运行时检测到它们。


In v5, in the case of an ambiguous method, it was necessary to
look up a method by its canonical normalized signature. In v6
the signature does not need to be normalized and the Typed API
provides a cleaner way to access the desired method.

In v5, duplicate definitions also injected warnings into the
console, since there was no way to detect them at run-time.

_code: v5 合约 @lang<script>
  abi = [
    "function foo(address bar)",
    "function foo(uint160 bar)",
  ]
  contract = new Contract(address, abi, provider)

  // 在 v5 中，必须指定完全限定的规范化
  // 签名才能访问所需的方法。例如：
  contract["foo(address)"](addr)

  // 这些会失败，因为签名没有规范化：
  contract["foo(address )"](addr)
  contract["foo(address addr)"](addr)

  // 这会失败，因为方法不明确：
  contract.foo(addr)

_code: v6 合约 @lang<script>
  abi = [
    "function foo(address bar)",
    "function foo(uint160 bar)",
  ]
  contract = new Contract(address, abi, provider)

  // 这些都可以正常工作：
  contract["foo(address)"](addr)
  contract["foo(address )"](addr)
  contract["foo(address addr)"](addr)

  // 这仍然失败，因为没法知道哪个方法是要调用的
  contract.foo(addr)

  // However, the Typed API makes things a bit easier, since it
  // allows providing typing information to the Contract:
  contract.foo(Typed.address(addr))

_heading: Other Method Operations

In v5, contracts contained a series of method buckets, which
then in turn had all signatures and non-ambiguous names
attached to them to perform less-common operations.

In v6, the methods each have their own less-common operations
attached directly to them.

_code: other operations in v5  @lang<script>

  // The default action chooses send or call base on method
  // type (pure, view, constant, non-payable or payable)
  contract.foo(addr)

  // This would perform the default action, but return a Result
  // object, instead of destructing the value
  contract.functions.foo(addr)

  // Forces using call
  contract.staticCall.foo(addr)

  // Estimate the gas
  contract.estimateGas.foo(addr)

  // Populate a transaction
  contract.populateTransaction.foo(addr)

_code: other operations in v6  @lang<script>

  // Still behaves the same
  contract.foo(addr)

  // Perform a call, returning a Result object directly
  contract.foo.staticCallResult(addr)

  // Forces using call (even for payable and non-payable)
  contract.foo.staticCall(addr)

  // Forces sending a transaction (even for pure and view)
  contract.foo.send(addr)

  // Estimate the gas
  contract.foo.estimateGas(addr)

  // Populate a transaction
  contract.foo.populateTransaction(addr)


_subsection: Importing  @<migrate-importing>

In v5, the project was maintained as a large set of sub-packages
managed as a monorepo.

In v6 all imports are available in the root package, and for those
who wish to have finer-grained control, the ``pkg.exports`` makes
certain folders avilable directly.

_code: importing in v5  @lang<script>

  // Many things (but not all) we available on the root package
  import { ethers } from "ethers"

  // But some packages were grouped behind an additional property
  import { providers } from "ethers"
  const { InfuraProvider } = providers

  // For granular control, importing from the sub-package
  // was necessary
  import { InfuraProvider } from "@ethersproject/providers"

_code: importing in v6  @lang<script>

  // Everything is available on the root package
  import { ethers } from "ethers"
  import { InfuraProvider } from "ethers"

  // The pkg.exports provides granular access
  import { InfuraProvider } from "ethers/providers"


_subsection: Odds and Ends @<migrate-other>


_code: default AbiCoder  @lang<script>
  // In v5, it is a property of AbiCoder
  coder = AbiCoder.defaultAbiCoder

  // In v6, it is a static function on AbiCoder, which uses
  // a singleton pattern; the first time it is called, the
  // AbiCoder is created and on subsequent calls that initial
  // instance is returned.
  coder = AbiCoder.defaultAbiCoder()
